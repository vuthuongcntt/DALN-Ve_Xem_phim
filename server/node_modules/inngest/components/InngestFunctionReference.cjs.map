{"version":3,"file":"InngestFunctionReference.cjs","names":["opts: { functionId: string; appId?: string }"],"sources":["../../src/components/InngestFunctionReference.ts"],"sourcesContent":["import type { IsAny, Simplify } from \"../helpers/types.ts\";\nimport type {\n  ResolveSchema,\n  ValidSchemaInput,\n  ValidSchemaOutput,\n} from \"../helpers/validators/index.ts\";\nimport type {\n  MinimalEventPayload,\n  PayloadForAnyInngestFunction,\n} from \"../types.ts\";\nimport type { GetFunctionOutput } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport class InngestFunctionReference<\n  /**\n   * The payload expected by the referenced function.\n   *\n   * Must be in the shape of an event payload.\n   */\n  _TInput extends MinimalEventPayload,\n  /**\n   * The output of the referenced function.\n   */\n  _TOutput,\n> {\n  get [Symbol.toStringTag](): typeof InngestFunctionReference.Tag {\n    return InngestFunctionReference.Tag;\n  }\n\n  constructor(public readonly opts: { functionId: string; appId?: string }) {}\n}\n\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nexport const referenceFunction = <\n  TArgs extends InngestFunctionReference.HelperGenericArgs<TFnInput, TFnOutput>,\n  TFnInput extends ValidSchemaInput = ValidSchemaInput,\n  TFnOutput extends ValidSchemaOutput = ValidSchemaOutput,\n>({\n  functionId,\n  appId,\n}: TArgs extends InngestFunction.Any\n  ? // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    Omit<InngestFunctionReference.HelperArgs<any, any>, \"schemas\">\n  : TArgs): InngestFunctionReference.HelperReturn<TArgs> => {\n  return new InngestFunctionReference({\n    functionId,\n    appId,\n  }) as InngestFunctionReference.HelperReturn<TArgs>;\n};\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport namespace InngestFunctionReference {\n  export const Tag = \"Inngest.FunctionReference\" as const;\n\n  /**\n   * Represents any `InngestFunctionReference`.\n   *\n   * @public\n   */\n  export type Any = InngestFunctionReference<\n    MinimalEventPayload,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any\n  >;\n\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestFunctionReference.Tag;\n  }\n\n  /**\n   * Arguments used by {@link referenceFunction} to create a reference to an\n   * `InngestFunction`.\n   *\n   * @public\n   */\n  export type HelperArgs<TFnInput, TFnOutput> = {\n    /**\n     * The ID of the function to reference. This can be either a local function\n     * ID or the ID of a function that exists in another app.\n     *\n     * If the latter, `appId` must also be provided. If `appId` is not provided,\n     * the function ID will be assumed to be a local function ID (the app ID of\n     * the calling app will be used).\n     */\n    functionId: string;\n\n    /**\n     * The ID of the app that the function belongs to. This is only required if\n     * the function being referenced exists in another app.\n     */\n    appId?: string;\n\n    /**\n     * The schemas of the referenced function, providing typing to the input\n     * `data` and `return` of invoking the referenced function.\n     *\n     * If not provided and a local function type is not being passed as a\n     * generic into {@link referenceFunction}, the schemas will be inferred as\n     * `unknown`.\n     */\n    schemas?: {\n      data?: TFnInput;\n      return?: TFnOutput;\n    };\n  };\n\n  /**\n   * A helper type that allows the passing of either `HelperArgs` or\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place of\n   * inferring options.\n   *\n   * This is used along with defaults to allow a generic to be passed by the\n   * user and still infer the correct types for other arguments being passed in.\n   *\n   * @public\n   */\n  export type HelperGenericArgs<TFnInput, TFnOutput> =\n    | HelperArgs<TFnInput, TFnOutput>\n    | InngestFunction.Any;\n\n  /**\n   * Given a set of `InngestFunctionReference.ConstructorArgs`, return an\n   * `InngestFunctionReference`. Also handles the manual passing of\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place\n   * of inferring options.\n   *\n   * @public\n   */\n  export type HelperReturn<TArgs> = TArgs extends InngestFunction.Any\n    ? InngestFunctionReference<\n        PayloadForAnyInngestFunction<TArgs>,\n        GetFunctionOutput<TArgs>\n      >\n    : TArgs extends HelperArgs<infer TFnInput, infer TFnOutput>\n      ? InngestFunctionReference<\n          // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n          IsAny<ResolveSchema<TFnInput, TFnInput, any>> extends true\n            ? MinimalEventPayload\n            : Simplify<\n                // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                MinimalEventPayload<ResolveSchema<TFnInput, TFnInput, any>> &\n                  Required<\n                    Pick<\n                      MinimalEventPayload<\n                        // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                        ResolveSchema<TFnInput, TFnInput, any>\n                      >,\n                      \"data\"\n                    >\n                  >\n              >,\n          ResolveSchema<TFnOutput, TFnOutput, unknown>\n        >\n      : never;\n}\n"],"mappings":";;;;;;;;;;;;;;AAyBA,IAAa,2BAAb,MAAa,yBAWX;CACA,KAAK,OAAO,eAAoD;AAC9D,SAAO,yBAAyB;;CAGlC,YAAY,AAAgBA,MAA8C;EAA9C;;;;;;;;;;;;;AAa9B,MAAa,qBAIX,EACA,YACA,YAI0D;AAC1D,QAAO,IAAI,yBAAyB;EAClC;EACA;EACD,CAAC;;;iCAgBiB"}