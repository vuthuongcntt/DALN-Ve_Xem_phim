{"version":3,"file":"InngestExecution.cjs","names":["ExecutionVersion","options: InngestExecutionOptions","debugPrefix"],"sources":["../../../src/components/execution/InngestExecution.ts"],"sourcesContent":["import Debug, { type Debugger } from \"debug\";\nimport { debugPrefix, ExecutionVersion } from \"../../helpers/consts.ts\";\nimport type { ServerTiming } from \"../../helpers/ServerTiming.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport type { Context, IncomingOp, OutgoingOp } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { ActionResponse } from \"../InngestCommHandler.ts\";\nimport type { InngestFunction } from \"../InngestFunction.ts\";\n\n// Re-export ExecutionVersion so it's correctly recognized as an enum and not\n// just a type. This can be lost when bundling if we don't re-export it here.\n// See `pnpm run test:dist`.\nexport { ExecutionVersion };\n\n/**\n * The possible results of an execution.\n */\nexport interface ExecutionResults {\n  \"function-resolved\": { data: unknown };\n  \"step-ran\": { step: OutgoingOp; retriable?: boolean | string };\n  \"function-rejected\": { error: unknown; retriable: boolean | string };\n  \"steps-found\": { steps: [OutgoingOp, ...OutgoingOp[]] };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\nexport type ExecutionResult = {\n  [K in keyof ExecutionResults]: Simplify<\n    {\n      type: K;\n      ctx: Context.Any;\n      ops: Record<string, MemoizedOp>;\n    } & ExecutionResults[K]\n  >;\n}[keyof ExecutionResults];\n\nexport type ExecutionResultHandler<T = ActionResponse> = (\n  result: ExecutionResult,\n) => MaybePromise<T>;\n\nexport type ExecutionResultHandlers<T = ActionResponse> = {\n  [E in ExecutionResult as E[\"type\"]]: (result: E) => MaybePromise<T>;\n};\n\nexport interface MemoizedOp extends IncomingOp {\n  /**\n   * If the step has been hit during this run, these will be the arguments\n   * passed to it.\n   */\n  rawArgs?: unknown[];\n  fulfilled?: boolean;\n\n  /**\n   * The promise that has been returned to userland code.\n   */\n  promise?: Promise<unknown>;\n  seen?: boolean;\n}\n\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexport const PREFERRED_EXECUTION_VERSION =\n  ExecutionVersion.V1 satisfies ExecutionVersion;\n\n/**\n * Options for creating a new {@link InngestExecution} instance.\n */\nexport interface InngestExecutionOptions {\n  client: Inngest.Any;\n  fn: InngestFunction.Any;\n  reqArgs: unknown[];\n  runId: string;\n  data: Omit<Context.Any, \"step\">;\n  stepState: Record<string, MemoizedOp>;\n  stepCompletionOrder: string[];\n\n  /**\n   * Headers to be sent with any request to Inngest during this execution.\n   */\n  headers: Record<string, string>;\n  requestedRunStep?: string;\n  timer?: ServerTiming;\n  isFailureHandler?: boolean;\n  disableImmediateExecution?: boolean;\n\n  /**\n   * Provide the ability to transform the context passed to the function before\n   * the execution starts.\n   */\n  transformCtx?: (ctx: Readonly<Context.Any>) => Context.Any;\n}\n\nexport type InngestExecutionFactory = (\n  options: InngestExecutionOptions,\n) => IInngestExecution;\n\nexport class InngestExecution {\n  protected debug: Debugger;\n\n  constructor(protected options: InngestExecutionOptions) {\n    this.debug = Debug(`${debugPrefix}:${this.options.runId}`);\n  }\n}\n\nexport interface IInngestExecution {\n  start(): Promise<ExecutionResult>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAiEA,MAAa,8BACXA,gCAAiB;AAkCnB,IAAa,mBAAb,MAA8B;CAC5B,AAAU;CAEV,YAAY,AAAUC,SAAkC;EAAlC;AACpB,OAAK,2BAAc,GAAGC,2BAAY,GAAG,KAAK,QAAQ,QAAQ"}