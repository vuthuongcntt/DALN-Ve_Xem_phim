{"version":3,"file":"v0.js","names":["createV0InngestExecution: InngestExecutionFactory","state: V0ExecutionState","stepHandler: StepHandler","retriable: boolean | string"],"sources":["../../../src/components/execution/v0.ts"],"sourcesContent":["import canonicalize from \"canonicalize\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  deserializeError,\n  ErrCode,\n  functionStoppedRunningErr,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.ts\";\nimport { undefinedToNull } from \"../../helpers/functions.ts\";\nimport {\n  resolveAfterPending,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, PartialK } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type HashedOp,\n  type IncomingOp,\n  jsonErrorSchema,\n  type OpStack,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  getStepOptions,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV0InngestExecution: InngestExecutionFactory = (options) => {\n  return new V0InngestExecution(options);\n};\n\nexport class V0InngestExecution\n  extends InngestExecution\n  implements IInngestExecution\n{\n  private state: V0ExecutionState;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n  private fnArg: Context.Any;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n  }\n\n  public start() {\n    this.debug(\"starting V0 execution\");\n\n    // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n    return (this.execution ??= this._start().then((result) => {\n      this.debug(\"result:\", result);\n      return result;\n    }));\n  }\n\n  private async _start(): Promise<ExecutionResult> {\n    this.state.hooks = await this.initializeMiddleware();\n\n    try {\n      await this.transformInput();\n      await this.state.hooks.beforeMemoization?.();\n\n      if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n        await this.state.hooks.afterMemoization?.();\n        await this.state.hooks.beforeExecution?.();\n      }\n\n      const userFnPromise = runAsPromise(() => this.userFnToRun(this.fnArg));\n\n      let pos = -1;\n\n      do {\n        if (pos >= 0) {\n          if (\n            !this.options.requestedRunStep &&\n            pos === this.state.opStack.length - 1\n          ) {\n            await this.state.hooks.afterMemoization?.();\n            await this.state.hooks.beforeExecution?.();\n          }\n\n          this.state.tickOps = {};\n          const incomingOp = this.state.opStack[pos] as IncomingOp;\n          this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n\n          if (!this.state.currentOp) {\n            /**\n             * We're trying to resume the function, but we can't find where to go.\n             *\n             * This means that either the function has changed or there are async\n             * actions in-between steps that we haven't noticed in previous\n             * executions.\n             *\n             * Whichever the case, this is bad and we can't continue in this\n             * undefined state.\n             */\n            throw new NonRetriableError(\n              prettyError({\n                whatHappened: \" Your function was stopped from running\",\n                why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                consequences:\n                  \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                toFixNow:\n                  \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                otherwise:\n                  \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                stack: true,\n                code: ErrCode.NON_DETERMINISTIC_FUNCTION,\n              }),\n            );\n          }\n\n          this.state.currentOp.fulfilled = true;\n\n          if (typeof incomingOp.data !== \"undefined\") {\n            this.state.currentOp.resolve(incomingOp.data);\n          } else {\n            this.state.currentOp.reject(incomingOp.error);\n          }\n        }\n\n        await resolveAfterPending();\n        this.state.reset();\n        pos++;\n      } while (pos < this.state.opStack.length);\n\n      await this.state.hooks.afterMemoization?.();\n\n      const discoveredOps = Object.values(this.state.tickOps).map<OutgoingOp>(\n        tickOpToOutgoing,\n      );\n\n      const runStep =\n        this.options.requestedRunStep ||\n        this.getEarlyExecRunStep(discoveredOps);\n\n      if (runStep) {\n        const userFnOp = this.state.allFoundOps[runStep];\n        const stepToRun = userFnOp?.fn;\n\n        if (!stepToRun) {\n          throw new Error(\n            `Bad stack; executor requesting to run unknown step \"${runStep}\"`,\n          );\n        }\n\n        const outgoingUserFnOp = {\n          ...tickOpToOutgoing(userFnOp),\n          op: StepOpCode.Step,\n        };\n\n        await this.state.hooks.beforeExecution?.();\n        this.state.executingStep = true;\n\n        const result = await runAsPromise(stepToRun)\n          .finally(() => {\n            this.state.executingStep = false;\n          })\n          .catch(async (error: Error) => {\n            return await this.transformOutput({ error }, outgoingUserFnOp);\n          })\n          .then(async (data) => {\n            await this.state.hooks?.afterExecution?.();\n            return await this.transformOutput({ data }, outgoingUserFnOp);\n          });\n\n        const { type: _type, ...rest } = result;\n\n        return {\n          type: \"step-ran\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          step: { ...outgoingUserFnOp, ...rest },\n        };\n      }\n\n      if (!discoveredOps.length) {\n        const fnRet = await Promise.race([\n          userFnPromise.then((data) => ({ type: \"complete\", data }) as const),\n          resolveNextTick().then(() => ({ type: \"incomplete\" }) as const),\n        ]);\n\n        if (fnRet.type === \"complete\") {\n          await this.state.hooks.afterExecution?.();\n\n          const allOpsFulfilled = Object.values(this.state.allFoundOps).every(\n            (op) => {\n              return op.fulfilled;\n            },\n          );\n\n          if (allOpsFulfilled) {\n            return await this.transformOutput({ data: fnRet.data });\n          }\n        } else if (!this.state.hasUsedTools) {\n          this.state.nonStepFnDetected = true;\n          const data = await userFnPromise;\n          await this.state.hooks.afterExecution?.();\n          return await this.transformOutput({ data });\n        } else {\n          const hasOpsPending = Object.values(this.state.allFoundOps).some(\n            (op) => {\n              return op.fulfilled === false;\n            },\n          );\n\n          if (!hasOpsPending) {\n            throw new NonRetriableError(\n              functionStoppedRunningErr(\n                ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION,\n              ),\n            );\n          }\n        }\n      }\n\n      await this.state.hooks.afterExecution?.();\n\n      return {\n        type: \"steps-found\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        steps: discoveredOps as [OutgoingOp, ...OutgoingOp[]],\n      };\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      await this.state.hooks.beforeResponse?.();\n    }\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n\n  private createExecutionState(): V0ExecutionState {\n    const state: V0ExecutionState = {\n      allFoundOps: {},\n      tickOps: {},\n      tickOpHashes: {},\n      currentOp: undefined,\n      hasUsedTools: false,\n      reset: () => {\n        state.tickOpHashes = {};\n        state.allFoundOps = { ...state.allFoundOps, ...state.tickOps };\n      },\n      nonStepFnDetected: false,\n      executingStep: false,\n      opStack: this.options.stepCompletionOrder.reduce<IncomingOp[]>(\n        (acc, stepId) => {\n          const stepState = this.options.stepState[stepId];\n          if (!stepState) {\n            return acc;\n          }\n\n          return [...acc, stepState];\n        },\n        [],\n      ),\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(\n      Object.entries(this.state.allFoundOps).map<[string, MemoizedOp]>(\n        ([id, op]) => [\n          id,\n          {\n            id: op.id,\n            rawArgs: op.rawArgs,\n            data: op.data,\n            error: op.error,\n            fulfilled: op.fulfilled,\n            seen: true,\n          },\n        ],\n      ),\n    );\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    // TODO: Review; inferred types results in an `any` here!\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private createFnArg(): Context.Any {\n    // Start referencing everything\n    this.state.tickOps = this.state.allFoundOps;\n\n    /**\n     * Create a unique hash of an operation using only a subset of the operation's\n     * properties; will never use `data` and will guarantee the order of the\n     * object so we don't rely on individual tools for that.\n     *\n     * If the operation already contains an ID, the current ID will be used\n     * instead, so that users can provide their own IDs.\n     */\n    const hashOp = (\n      /**\n       * The op to generate a hash from. We only use a subset of the op's\n       * properties when creating the hash.\n       */\n      op: PartialK<HashedOp, \"id\">,\n    ): HashedOp => {\n      /**\n       * It's difficult for v0 to understand whether or not an op has\n       * historically contained a custom ID, as all step usage now require them.\n       *\n       * For this reason, we make the assumption that steps in v0 do not have a\n       * custom ID and generate one for them as we would in all recommendations\n       * and examples.\n       */\n      const obj = {\n        parent: this.state.currentOp?.id ?? null,\n        op: op.op,\n        name: op.name as string,\n\n        // Historically, no v0 runs could have options for `step.run()` call,\n        // but this object can be specified in future versions.\n        //\n        // For this purpose, we change this to always use `null` if the op is\n        // that of a `step.run()`.\n        opts: op.op === StepOpCode.StepPlanned ? null : (op.opts ?? null),\n      };\n\n      const collisionHash = _internals.hashData(obj);\n\n      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n      const pos = (this.state.tickOpHashes[collisionHash] =\n        (this.state.tickOpHashes[collisionHash] ?? -1) + 1);\n\n      return {\n        ...op,\n        id: _internals.hashData({ pos, ...obj }),\n      };\n    };\n\n    const stepHandler: StepHandler = ({ args, matchOp, opts }) => {\n      if (this.state.nonStepFnDetected) {\n        throw new NonRetriableError(\n          functionStoppedRunningErr(ErrCode.STEP_USED_AFTER_ASYNC),\n        );\n      }\n\n      if (this.state.executingStep) {\n        throw new NonRetriableError(\n          prettyError({\n            whatHappened: \"Your function was stopped from running\",\n            why: \"We detected that you have nested `step.*` tooling.\",\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            otherwise:\n              \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      this.state.hasUsedTools = true;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n\n      return new Promise<unknown>((resolve, reject) => {\n        this.state.tickOps[opId.id] = {\n          ...opId,\n          ...(opts?.fn ? { fn: () => opts.fn?.(...args) } : {}),\n          rawArgs: args,\n          resolve,\n          reject,\n          fulfilled: false,\n        };\n      });\n    };\n\n    const step = createStepTools(this.options.client, this, stepHandler);\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.options.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.opStack = [...inputMutations.steps];\n    }\n  }\n\n  private getEarlyExecRunStep(ops: OutgoingOp[]): string | undefined {\n    if (ops.length !== 1) return;\n\n    const op = ops[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.id;\n    }\n\n    return;\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n    step?: Readonly<Omit<OutgoingOp, \"id\">>,\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError };\n\n    if (typeof output.error !== \"undefined\") {\n      output.data = serializeError(output.error);\n    }\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!step) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(error instanceof NonRetriableError);\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = serializeError(error);\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n}\n\ninterface TickOp extends HashedOp {\n  rawArgs: unknown[];\n  fn?: (...args: unknown[]) => unknown;\n  fulfilled: boolean;\n  resolve: (value: MaybePromise<unknown>) => void;\n  reject: (reason?: unknown) => void;\n}\n\nexport interface V0ExecutionState {\n  /**\n   * The tree of all found ops in the entire invocation.\n   */\n  allFoundOps: Record<string, TickOp>;\n\n  /**\n   * All synchronous operations found in this particular tick. The array is\n   * reset every tick.\n   */\n  tickOps: Record<string, TickOp>;\n\n  /**\n   * A hash of operations found within this tick, with keys being the hashed\n   * ops themselves (without a position) and the values being the number of\n   * times that op has been found.\n   *\n   * This is used to provide some mutation resilience to the op stack,\n   * allowing us to survive same-tick mutations of code by ensuring per-tick\n   * hashes are based on uniqueness rather than order.\n   */\n  tickOpHashes: Record<string, number>;\n\n  /**\n   * Tracks the current operation being processed. This can be used to\n   * understand the contextual parent of any recorded operations.\n   */\n  currentOp: TickOp | undefined;\n\n  /**\n   * If we've found a user function to run, we'll store it here so a component\n   * higher up can invoke and await it.\n   */\n  userFnToRun?: (...args: unknown[]) => unknown;\n\n  /**\n   * A boolean to represent whether the user's function is using any step\n   * tools.\n   *\n   * If the function survives an entire tick of the event loop and hasn't\n   * touched any tools, we assume that it is a single-step async function and\n   * should be awaited as usual.\n   */\n  hasUsedTools: boolean;\n\n  /**\n   * A function that should be used to reset the state of the tools after a\n   * tick has completed.\n   */\n  reset: () => void;\n\n  /**\n   * If `true`, any use of step tools will, by default, throw an error. We do\n   * this when we detect that a function may be mixing step and non-step code.\n   *\n   * Created step tooling can decide how to manually handle this on a\n   * case-by-case basis.\n   *\n   * In the future, we can provide a way for a user to override this if they\n   * wish to and understand the danger of side-effects.\n   *\n   * Defaults to `false`.\n   */\n  nonStepFnDetected: boolean;\n\n  /**\n   * When true, we are currently executing a user's code for a single step\n   * within a step function.\n   */\n  executingStep: boolean;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * The op stack to pass to the function as state, likely stored in\n   * `ctx._state` in the Inngest payload.\n   *\n   * This must be provided in order to always be cognizant of step function\n   * state and to allow for multi-step functions.\n   */\n  opStack: OpStack;\n}\n\nconst tickOpToOutgoing = (op: TickOp): OutgoingOp => {\n  return {\n    op: op.op,\n    id: op.id,\n    name: op.name,\n    opts: op.opts,\n  };\n};\n\n/**\n * An operation ready to hash to be used to memoise step function progress.\n *\n * @internal\n */\nexport type UnhashedOp = {\n  name: string;\n  op: StepOpCode;\n  opts: Record<string, unknown> | null;\n  parent: string | null;\n  pos?: number;\n};\n\nconst hashData = (op: UnhashedOp): string => {\n  return sha1().update(canonicalize(op)).digest(\"hex\");\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashData };\n"],"mappings":"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"}