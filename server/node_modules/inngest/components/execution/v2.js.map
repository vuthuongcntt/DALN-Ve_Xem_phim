{"version":3,"file":"v2.js","names":["createV2InngestExecution: InngestExecutionFactory","step","outgoingOp: OutgoingOp","retriable: boolean | string","loop: V2ExecutionState[\"loop\"]","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","stepHandler: StepHandler","extraOpts: Record<string, unknown> | undefined","step: FoundStep"],"sources":["../../../src/components/execution/v2.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport { headerKeys, internalEvents } from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.js\";\nimport { undefinedToNull } from \"../../helpers/functions.js\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV2InngestExecution: InngestExecutionFactory = (options) => {\n  return new V2InngestExecution(options);\n};\n\nclass V2InngestExecution extends InngestExecution implements IInngestExecution {\n  private state: V2ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers = this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V2 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V2 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          { app: this.options.client, ctx: this.fnArg },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": (checkpoint) => {\n        this.debug(\"checkpoint:\", checkpoint);\n      },\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async (checkpoint) => {\n        return await this.transformOutput({ data: checkpoint.data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          const transformResult = await this.transformOutput(stepResult);\n\n          /**\n           * Transforming output will always return either function rejection or\n           * resolution. In most cases, this can be immediately returned, but in\n           * this particular case we want to handle it differently.\n           */\n          if (transformResult.type === \"function-resolved\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                data: transformResult.data,\n              }),\n            };\n          } else if (transformResult.type === \"function-rejected\") {\n            const stepForResponse = _internals.hashOp({\n              ...stepResult,\n              error: transformResult.error,\n            });\n\n            if (stepResult.op === StepOpCode.StepFailed) {\n              const ser = serializeError(transformResult.error);\n              stepForResponse.data = {\n                __serialized: true,\n                name: ser.name,\n                message: ser.message,\n                stack: \"\",\n              };\n            }\n\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              retriable: transformResult.retriable,\n              step: stepForResponse,\n            };\n          }\n\n          return transformResult;\n        }\n\n        const newSteps = await this.filterNewSteps(\n          Array.from(this.state.steps.values()),\n        );\n        if (newSteps) {\n          return {\n            type: \"steps-found\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            steps: newSteps,\n          };\n        }\n\n        return;\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n      },\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers) {\n    return this.checkpointHandlers[type] as (\n      checkpoint: Checkpoint,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    /**\n     * Gather any steps that aren't memoized and report them.\n     */\n    const newSteps = foundSteps.filter((step) => !step.fulfilled);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * Warn if we've found new steps but haven't yet seen all previous\n     * steps. This may indicate that step presence isn't determinate.\n     */\n    let knownSteps = 0;\n    for (const step of foundSteps) {\n      if (step.fulfilled) {\n        knownSteps++;\n      }\n    }\n    const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n\n    if (!foundAllCompletedSteps) {\n      // TODO Tag\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"Function may be indeterminate\",\n          why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n          consequences:\n            \"This may cause unexpected behaviour as Inngest executes your function.\",\n          reassurance:\n            \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n        }),\n      );\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store) {\n      store.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    return runAsPromise(fn)\n      .finally(async () => {\n        if (store) {\n          delete store.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>((data) => {\n        return {\n          ...outgoingOp,\n          data,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        let errorIsRetriable = true;\n\n        if (error instanceof NonRetriableError) {\n          errorIsRetriable = false;\n        } else if (\n          this.fnArg.maxAttempts &&\n          this.fnArg?.maxAttempts - 1 === this.fnArg.attempt\n        ) {\n          errorIsRetriable = false;\n        }\n\n        if (errorIsRetriable) {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepError,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        } else {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepFailed,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        }\n      });\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError } as Partial<OutgoingOp>;\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError ||\n        (error instanceof StepError &&\n          error === this.state.recentlyRejectedStepError)\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V2ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V2ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V2ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (const [hashedId, step] of unhandledFoundStepsToReport) {\n            if (step.handle()) {\n              unhandledFoundStepsToReport.delete(hashedId);\n              if (step.fulfilled) {\n                foundStepsToReport.delete(step.id);\n              }\n            }\n          }\n\n          if (foundStepsToReport.size) {\n            const steps = [...foundStepsToReport.values()] as [\n              FoundStep,\n              ...FoundStep[],\n            ];\n\n            foundStepsToReport.clear();\n\n            return void this.state.setCheckpoint({\n              type: \"steps-found\",\n              steps: steps,\n            });\n          }\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.id, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(opId.id)) {\n        const originalId = opId.id;\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(newId)) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          step.handled = true;\n\n          if (isFulfilled && stepState) {\n            stepState.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([\n              stepState.data,\n              stepState.error,\n              stepState.input,\n            ]).then(() => {\n              if (typeof stepState.data !== \"undefined\") {\n                resolve(stepState.data);\n              } else {\n                this.state.recentlyRejectedStepError = new StepError(\n                  opId.id,\n                  stepState.error,\n                );\n                reject(this.state.recentlyRejectedStepError);\n              }\n            });\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(opId.id, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V2ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = {\n  [C in Checkpoint as C[\"type\"]]: (\n    checkpoint: C,\n  ) => MaybePromise<ExecutionResult | undefined>;\n} & {\n  \"\": (checkpoint: Checkpoint) => MaybePromise<void>;\n};\n\nexport interface V2ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"mappings":"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"}