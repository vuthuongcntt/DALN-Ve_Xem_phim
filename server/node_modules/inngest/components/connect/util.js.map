{"version":3,"file":"util.js","names":["attempt: number","parsedTraceCtx: unknown"],"sources":["../../../src/components/connect/util.ts"],"sourcesContent":["import { headerKeys } from \"../../helpers/consts.ts\";\n\nexport class ReconnectError extends Error {\n  constructor(\n    message: string,\n    public attempt: number,\n  ) {\n    super(message);\n    this.name = \"ReconnectError\";\n  }\n}\n\nexport class AuthError extends ReconnectError {\n  constructor(message: string, attempt: number) {\n    super(message, attempt);\n    this.name = \"AuthError\";\n  }\n}\n\nexport class ConnectionLimitError extends ReconnectError {\n  constructor(attempt: number) {\n    super(\"Connection limit exceeded\", attempt);\n    this.name = \"ConnectionLimitError\";\n  }\n}\n\nexport function expBackoff(attempt: number): number {\n  const backoffTimes = [\n    1000, 2000, 5000, 10_000, 20_000, 30_000, 60_000, 120_000, 300_000,\n  ];\n\n  // If attempt exceeds array length, use the last (maximum) value\n  return backoffTimes[Math.min(attempt, backoffTimes.length - 1)] ?? 60_000;\n}\n\n/**\n * Wait for a given amount of time, but cancel if the given condition is true.\n *\n * Returns `true` if the condition was met, `false` if the timeout was reached.\n */\nexport function waitWithCancel(ms: number, cancelIf: () => boolean) {\n  return new Promise<boolean>((resolve) => {\n    const startTime = Date.now();\n    const interval = setInterval(() => {\n      if (cancelIf()) {\n        clearInterval(interval);\n        resolve(true);\n        return;\n      }\n\n      if (Date.now() - startTime >= ms) {\n        clearInterval(interval);\n        resolve(false);\n        return;\n      }\n    }, 100);\n  });\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function parseTraceCtx(serializedTraceCtx: Uint8Array<ArrayBufferLike>) {\n  const parsedTraceCtx: unknown =\n    serializedTraceCtx.length > 0\n      ? JSON.parse(new TextDecoder().decode(serializedTraceCtx))\n      : null;\n\n  if (!isObject(parsedTraceCtx)) {\n    return null;\n  }\n\n  const traceParent = parsedTraceCtx[headerKeys.TraceParent];\n  if (!isString(traceParent)) {\n    return null;\n  }\n\n  const traceState = parsedTraceCtx[headerKeys.TraceState];\n  if (!isString(traceState)) {\n    return null;\n  }\n\n  return {\n    traceParent,\n    traceState,\n  };\n}\n"],"mappings":";;;AAEA,IAAa,iBAAb,cAAoC,MAAM;CACxC,YACE,SACA,AAAOA,SACP;AACA,QAAM,QAAQ;EAFP;AAGP,OAAK,OAAO;;;AAIhB,IAAa,YAAb,cAA+B,eAAe;CAC5C,YAAY,SAAiB,SAAiB;AAC5C,QAAM,SAAS,QAAQ;AACvB,OAAK,OAAO;;;AAIhB,IAAa,uBAAb,cAA0C,eAAe;CACvD,YAAY,SAAiB;AAC3B,QAAM,6BAA6B,QAAQ;AAC3C,OAAK,OAAO;;;AAIhB,SAAgB,WAAW,SAAyB;CAClD,MAAM,eAAe;EACnB;EAAM;EAAM;EAAM;EAAQ;EAAQ;EAAQ;EAAQ;EAAS;EAC5D;AAGD,QAAO,aAAa,KAAK,IAAI,SAAS,aAAa,SAAS,EAAE,KAAK;;;;;;;AAQrE,SAAgB,eAAe,IAAY,UAAyB;AAClE,QAAO,IAAI,SAAkB,YAAY;EACvC,MAAM,YAAY,KAAK,KAAK;EAC5B,MAAM,WAAW,kBAAkB;AACjC,OAAI,UAAU,EAAE;AACd,kBAAc,SAAS;AACvB,YAAQ,KAAK;AACb;;AAGF,OAAI,KAAK,KAAK,GAAG,aAAa,IAAI;AAChC,kBAAc,SAAS;AACvB,YAAQ,MAAM;AACd;;KAED,IAAI;GACP;;AAGJ,SAAS,SAAS,OAAkD;AAClE,QAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,MAAM;;AAG7E,SAAS,SAAS,OAAiC;AACjD,QAAO,OAAO,UAAU;;AAG1B,SAAgB,cAAc,oBAAiD;CAC7E,MAAMC,iBACJ,mBAAmB,SAAS,IACxB,KAAK,MAAM,IAAI,aAAa,CAAC,OAAO,mBAAmB,CAAC,GACxD;AAEN,KAAI,CAAC,SAAS,eAAe,CAC3B,QAAO;CAGT,MAAM,cAAc,eAAe,WAAW;AAC9C,KAAI,CAAC,SAAS,YAAY,CACxB,QAAO;CAGT,MAAM,aAAa,eAAe,WAAW;AAC7C,KAAI,CAAC,SAAS,WAAW,CACvB,QAAO;AAGT,QAAO;EACL;EACA;EACD"}