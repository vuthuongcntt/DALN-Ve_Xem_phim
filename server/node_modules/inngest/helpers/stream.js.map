{"version":3,"file":"stream.js","names":["passFinalize: (value: (data: unknown) => void) => void"],"sources":["../../src/helpers/stream.ts"],"sourcesContent":["import { stringify } from \"./strings.ts\";\n\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nexport const createStream = (opts?: {\n  /**\n   * The interval in milliseconds to send a heartbeat.\n   *\n   * Defaults to `3000`.\n   */\n  interval?: number;\n\n  /**\n   * The value to send as a heartbeat.\n   *\n   * Defaults to `\" \"`.\n   */\n  value?: string;\n}): Promise<{ finalize: (data: unknown) => void; stream: ReadableStream }> => {\n  /**\n   * We need to resolve this promise with both the stream and the `finalize`\n   * function, but having them both instantiated synchronously is difficult, as\n   * we need access to the stream's internals too.\n   *\n   * We create this cheeky deferred promise to grab the internal `finalize`\n   * value. Be warned that simpler solutions may appear to compile, but fail at\n   * runtime due to variables not being assigned; make sure to test your code!\n   */\n  let passFinalize: (value: (data: unknown) => void) => void;\n\n  const finalizeP = new Promise<(data: unknown) => void>((resolve) => {\n    passFinalize = resolve;\n  });\n\n  const interval = opts?.interval ?? 3000;\n  const value = opts?.value ?? \" \";\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      const stream = new ReadableStream({\n        start(controller) {\n          const encoder = new TextEncoder();\n\n          const heartbeat = setInterval(() => {\n            controller.enqueue(encoder.encode(value));\n          }, interval);\n\n          const finalize = (data: unknown) => {\n            clearInterval(heartbeat);\n\n            // `data` may be a `Promise`. If it is, we need to wait for it to\n            // resolve before sending it. To support this elegantly we'll always\n            // assume it's a promise and handle that case.\n            void Promise.resolve(data).then((resolvedData) => {\n              controller.enqueue(encoder.encode(stringify(resolvedData)));\n              controller.close();\n            });\n          };\n\n          passFinalize(finalize);\n        },\n      });\n\n      resolve({ stream, finalize: await finalizeP });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n"],"mappings":";;;;;;;;;;AASA,MAAa,gBAAgB,SAciD;;;;;;;;;;CAU5E,IAAIA;CAEJ,MAAM,YAAY,IAAI,SAAkC,YAAY;AAClE,iBAAe;GACf;CAEF,MAAM,WAAW,MAAM,YAAY;CACnC,MAAM,QAAQ,MAAM,SAAS;AAE7B,QAAO,IAAI,QAAQ,OAAO,SAAS,WAAW;AAC5C,MAAI;GACF,MAAM,SAAS,IAAI,eAAe,EAChC,MAAM,YAAY;IAChB,MAAM,UAAU,IAAI,aAAa;IAEjC,MAAM,YAAY,kBAAkB;AAClC,gBAAW,QAAQ,QAAQ,OAAO,MAAM,CAAC;OACxC,SAAS;IAEZ,MAAM,YAAY,SAAkB;AAClC,mBAAc,UAAU;AAKxB,KAAK,QAAQ,QAAQ,KAAK,CAAC,MAAM,iBAAiB;AAChD,iBAAW,QAAQ,QAAQ,OAAO,UAAU,aAAa,CAAC,CAAC;AAC3D,iBAAW,OAAO;OAClB;;AAGJ,iBAAa,SAAS;MAEzB,CAAC;AAEF,WAAQ;IAAE;IAAQ,UAAU,MAAM;IAAW,CAAC;WACvC,KAAK;AACZ,UAAO,IAAI;;GAEb"}