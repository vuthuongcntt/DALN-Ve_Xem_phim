{"version":3,"file":"temporal.js","names":[],"sources":["../../src/helpers/temporal.ts"],"sourcesContent":["import type { Temporal } from \"temporal-polyfill\";\n\n/**\n * A type that represents a `Temporal.Instant` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type InstantLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Instant\";\n};\n\n/**\n * A type that represents a `Temporal.Duration` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type DurationLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Duration\";\n};\n\n/**\n * A type that represents a `Temporal.ZonedDateTime` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type ZonedDateTimeLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.ZonedDateTime\";\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nexport const isTemporalDuration = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Duration => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Duration\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nexport const isTemporalInstant = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Instant => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Instant\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nexport const isTemporalZonedDateTime = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.ZonedDateTime => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nexport const getISOString = (\n  time: Date | string | InstantLike | ZonedDateTimeLike,\n): string => {\n  if (typeof time === \"string\") {\n    return new Date(time).toISOString();\n  }\n\n  if (time instanceof Date) {\n    return time.toISOString();\n  }\n\n  if (isTemporalZonedDateTime(time)) {\n    return time.toInstant().toString();\n  }\n\n  if (isTemporalInstant(time)) {\n    return time.toString();\n  }\n\n  throw new TypeError(\"Invalid date input\");\n};\n"],"mappings":";;;;AA4CA,MAAa,sBAIX,UAC+B;AAC/B,KAAI;AAEF,SAAQ,MAAc,OAAO,iBAAiB;SACxC;AACN,SAAO;;;;;;AAOX,MAAa,qBAIX,UAC8B;AAC9B,KAAI;AAEF,SAAQ,MAAc,OAAO,iBAAiB;SACxC;AACN,SAAO;;;;;;AAOX,MAAa,2BAIX,UACoC;AACpC,KAAI;AAEF,SAAQ,MAAc,OAAO,iBAAiB;SACxC;AACN,SAAO;;;;;;;AAQX,MAAa,gBACX,SACW;AACX,KAAI,OAAO,SAAS,SAClB,QAAO,IAAI,KAAK,KAAK,CAAC,aAAa;AAGrC,KAAI,gBAAgB,KAClB,QAAO,KAAK,aAAa;AAG3B,KAAI,wBAAwB,KAAK,CAC/B,QAAO,KAAK,WAAW,CAAC,UAAU;AAGpC,KAAI,kBAAkB,KAAK,CACzB,QAAO,KAAK,UAAU;AAGxB,OAAM,IAAI,UAAU,qBAAqB"}