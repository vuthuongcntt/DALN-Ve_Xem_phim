{"version":3,"file":"lambda.cjs","names":["frameworkName: SupportedFrameworkName","InngestCommHandler"],"sources":["../src/lambda.ts"],"sourcesContent":["/**\n * An adapter for AWS Lambda to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * @example\n *\n * ```ts\n * import { Inngest } from \"inngest\";\n * import { serve } from \"inngest/lambda\";\n *\n * const inngest = new Inngest({ id: \"my-lambda-app\" });\n *\n * const fn = inngest.createFunction(\n *   { id: \"hello-world\" },\n *   { event: \"test/hello.world\" },\n *   async ({ event }) => {\n *    return \"Hello World\";\n *  }\n * );\n *\n * export const handler = serve({ client: inngest, functions: [fn] });\n * ```\n *\n * @module\n */\n\nimport type {\n  APIGatewayEvent,\n  APIGatewayProxyEventV2,\n  APIGatewayProxyResult,\n  Context,\n} from \"aws-lambda\";\nimport {\n  InngestCommHandler,\n  type ServeHandlerOptions,\n} from \"./components/InngestCommHandler.ts\";\nimport type { Either } from \"./helpers/types.ts\";\nimport type { SupportedFrameworkName } from \"./types.ts\";\n\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexport const frameworkName: SupportedFrameworkName = \"aws-lambda\";\n\n/**\n * With AWS Lambda, serve and register any declared functions with Inngest,\n * making them available to be triggered by events.\n *\n * @example\n *\n * ```ts\n * import { Inngest } from \"inngest\";\n * import { serve } from \"inngest/lambda\";\n *\n * const inngest = new Inngest({ id: \"my-lambda-app\" });\n *\n * const fn = inngest.createFunction(\n *   { id: \"hello-world\" },\n *   { event: \"test/hello.world\" },\n *   async ({ event }) => {\n *    return \"Hello World\";\n *  }\n * );\n *\n * export const handler = serve({ client: inngest, functions: [fn] });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nexport const serve = (\n  options: ServeHandlerOptions,\n): ((\n  event: Either<APIGatewayEvent, APIGatewayProxyEventV2>,\n  _context: Context,\n) => Promise<APIGatewayProxyResult>) => {\n  const handler = new InngestCommHandler({\n    frameworkName,\n    ...options,\n    handler: (\n      event: Either<APIGatewayEvent, APIGatewayProxyEventV2>,\n      _context: Context,\n    ) => {\n      /**\n       * Try to handle multiple incoming event types, as Lambda can have many\n       * triggers.\n       *\n       * This still doesn't handle all cases, but it's a start.\n       */\n      const eventIsV2 = ((\n        ev: APIGatewayEvent | APIGatewayProxyEventV2,\n      ): ev is APIGatewayProxyEventV2 => {\n        return (ev as APIGatewayProxyEventV2).version === \"2.0\";\n      })(event);\n\n      // Create a map of headers\n      const headersMap = new Map<string, string | undefined>([\n        ...Object.entries(event.headers).map(\n          ([key, value]) =>\n            [key.toLowerCase().trim(), value] as [string, string | undefined],\n        ),\n      ]);\n\n      const getHeader = (key: string): string | undefined => {\n        return headersMap.get(key.toLowerCase().trim());\n      };\n\n      return {\n        body: () => {\n          return JSON.parse(\n            event.body\n              ? event.isBase64Encoded\n                ? Buffer.from(event.body, \"base64\").toString()\n                : event.body\n              : \"{}\",\n          );\n        },\n        headers: getHeader,\n        method: () => {\n          return eventIsV2\n            ? event.requestContext.http.method\n            : event.httpMethod;\n        },\n        url: () => {\n          const path = eventIsV2 ? event.requestContext.http.path : event.path;\n          const proto = getHeader(\"x-forwarded-proto\") || \"https\";\n          const url = new URL(path, `${proto}://${getHeader(\"host\") || \"\"}`);\n\n          return url;\n        },\n        queryString: (key) => {\n          return event.queryStringParameters?.[key];\n        },\n        transformResponse: ({\n          body,\n          status: statusCode,\n          headers,\n        }): Promise<APIGatewayProxyResult> => {\n          return Promise.resolve({ body, statusCode, headers });\n        },\n      };\n    },\n  });\n\n  return handler.createHandler();\n};\n"],"mappings":";;;;;;;AA2CA,MAAaA,gBAAwC;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BrD,MAAa,SACX,YAIsC;AAqEtC,QApEgB,IAAIC,8CAAmB;EACrC;EACA,GAAG;EACH,UACE,OACA,aACG;;;;;;;GAOH,MAAM,cACJ,OACiC;AACjC,WAAQ,GAA8B,YAAY;MACjD,MAAM;GAGT,MAAM,aAAa,IAAI,IAAgC,CACrD,GAAG,OAAO,QAAQ,MAAM,QAAQ,CAAC,KAC9B,CAAC,KAAK,WACL,CAAC,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CACpC,CACF,CAAC;GAEF,MAAM,aAAa,QAAoC;AACrD,WAAO,WAAW,IAAI,IAAI,aAAa,CAAC,MAAM,CAAC;;AAGjD,UAAO;IACL,YAAY;AACV,YAAO,KAAK,MACV,MAAM,OACF,MAAM,kBACJ,OAAO,KAAK,MAAM,MAAM,SAAS,CAAC,UAAU,GAC5C,MAAM,OACR,KACL;;IAEH,SAAS;IACT,cAAc;AACZ,YAAO,YACH,MAAM,eAAe,KAAK,SAC1B,MAAM;;IAEZ,WAAW;KACT,MAAM,OAAO,YAAY,MAAM,eAAe,KAAK,OAAO,MAAM;KAChE,MAAM,QAAQ,UAAU,oBAAoB,IAAI;AAGhD,YAFY,IAAI,IAAI,MAAM,GAAG,MAAM,KAAK,UAAU,OAAO,IAAI,KAAK;;IAIpE,cAAc,QAAQ;AACpB,YAAO,MAAM,wBAAwB;;IAEvC,oBAAoB,EAClB,MACA,QAAQ,YACR,cACoC;AACpC,YAAO,QAAQ,QAAQ;MAAE;MAAM;MAAY;MAAS,CAAC;;IAExD;;EAEJ,CAAC,CAEa,eAAe"}