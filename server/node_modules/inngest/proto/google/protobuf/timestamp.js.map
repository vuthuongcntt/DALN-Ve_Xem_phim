{"version":3,"file":"timestamp.js","names":["Timestamp: MessageFns<Timestamp>","obj: any"],"sources":["../../../../src/proto/google/protobuf/timestamp.ts"],"sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.6.1\n//   protoc               v5.29.4\n// source: google/protobuf/timestamp.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n */\nexport interface Timestamp {\n  /**\n   * Represents seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   */\n  seconds: number;\n  /**\n   * Non-negative fractions of a second at nanosecond resolution. Negative\n   * second values with fractions must still have non-negative nanos values\n   * that count forward in time. Must be from 0 to 999,999,999\n   * inclusive.\n   */\n  nanos: number;\n}\n\nfunction createBaseTimestamp(): Timestamp {\n  return { seconds: 0, nanos: 0 };\n}\n\nexport const Timestamp: MessageFns<Timestamp> = {\n  encode(message: Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.seconds !== 0) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Timestamp {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.seconds = longToNumber(reader.int64());\n          continue;\n        }\n        case 2: {\n          if (tag !== 16) {\n            break;\n          }\n\n          message.nanos = reader.int32();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Timestamp {\n    return {\n      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,\n      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,\n    };\n  },\n\n  toJSON(message: Timestamp): unknown {\n    const obj: any = {};\n    if (message.seconds !== 0) {\n      obj.seconds = Math.round(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      obj.nanos = Math.round(message.nanos);\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Timestamp>, I>>(base?: I): Timestamp {\n    return Timestamp.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(object: I): Timestamp {\n    const message = createBaseTimestamp();\n    message.seconds = object.seconds ?? 0;\n    message.nanos = object.nanos ?? 0;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction longToNumber(int64: { toString(): string }): number {\n  const num = globalThis.Number(int64.toString());\n  if (num > globalThis.Number.MAX_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (num < globalThis.Number.MIN_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return num;\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n"],"mappings":";;;AAsHA,SAAS,sBAAiC;AACxC,QAAO;EAAE,SAAS;EAAG,OAAO;EAAG;;AAGjC,MAAaA,YAAmC;CAC9C,OAAO,SAAoB,SAAuB,IAAI,cAAc,EAAgB;AAClF,MAAI,QAAQ,YAAY,EACtB,QAAO,OAAO,EAAE,CAAC,MAAM,QAAQ,QAAQ;AAEzC,MAAI,QAAQ,UAAU,EACpB,QAAO,OAAO,GAAG,CAAC,MAAM,QAAQ,MAAM;AAExC,SAAO;;CAGT,OAAO,OAAkC,QAA4B;EACnE,MAAM,SAAS,iBAAiB,eAAe,QAAQ,IAAI,aAAa,MAAM;EAC9E,IAAI,MAAM,WAAW,SAAY,OAAO,MAAM,OAAO,MAAM;EAC3D,MAAM,UAAU,qBAAqB;AACrC,SAAO,OAAO,MAAM,KAAK;GACvB,MAAM,MAAM,OAAO,QAAQ;AAC3B,WAAQ,QAAQ,GAAhB;IACE,KAAK;AACH,SAAI,QAAQ,EACV;AAGF,aAAQ,UAAU,aAAa,OAAO,OAAO,CAAC;AAC9C;IAEF,KAAK;AACH,SAAI,QAAQ,GACV;AAGF,aAAQ,QAAQ,OAAO,OAAO;AAC9B;;AAGJ,QAAK,MAAM,OAAO,KAAK,QAAQ,EAC7B;AAEF,UAAO,KAAK,MAAM,EAAE;;AAEtB,SAAO;;CAGT,SAAS,QAAwB;AAC/B,SAAO;GACL,SAAS,MAAM,OAAO,QAAQ,GAAG,WAAW,OAAO,OAAO,QAAQ,GAAG;GACrE,OAAO,MAAM,OAAO,MAAM,GAAG,WAAW,OAAO,OAAO,MAAM,GAAG;GAChE;;CAGH,OAAO,SAA6B;EAClC,MAAMC,MAAW,EAAE;AACnB,MAAI,QAAQ,YAAY,EACtB,KAAI,UAAU,KAAK,MAAM,QAAQ,QAAQ;AAE3C,MAAI,QAAQ,UAAU,EACpB,KAAI,QAAQ,KAAK,MAAM,QAAQ,MAAM;AAEvC,SAAO;;CAGT,OAAmD,MAAqB;AACtE,SAAO,UAAU,YAAY,QAAS,EAAE,CAAS;;CAEnD,YAAwD,QAAsB;EAC5E,MAAM,UAAU,qBAAqB;AACrC,UAAQ,UAAU,OAAO,WAAW;AACpC,UAAQ,QAAQ,OAAO,SAAS;AAChC,SAAO;;CAEV;AAcD,SAAS,aAAa,OAAuC;CAC3D,MAAM,MAAM,WAAW,OAAO,MAAM,UAAU,CAAC;AAC/C,KAAI,MAAM,WAAW,OAAO,iBAC1B,OAAM,IAAI,WAAW,MAAM,+CAA+C;AAE5E,KAAI,MAAM,WAAW,OAAO,iBAC1B,OAAM,IAAI,WAAW,MAAM,gDAAgD;AAE7E,QAAO;;AAGT,SAAS,MAAM,OAAqB;AAClC,QAAO,UAAU,QAAQ,UAAU"}