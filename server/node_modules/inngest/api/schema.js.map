{"version":3,"file":"schema.js","names":[],"sources":["../../src/api/schema.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ExecutionVersion } from \"../helpers/consts.ts\";\nimport { type EventPayload, jsonErrorSchema } from \"../types.ts\";\n\nexport const errorSchema = z.object({\n  error: z.string(),\n  status: z.number(),\n});\nexport type ErrorResponse = z.infer<typeof errorSchema>;\n\nconst v0StepSchema = z\n  .record(\n    z.any().refine((v) => typeof v !== \"undefined\", {\n      message: \"Values in steps must be defined\",\n    }),\n  )\n  .optional()\n  .nullable();\n\nconst v1StepSchema = z\n  .record(\n    z\n      .object({\n        type: z.literal(\"data\").optional().default(\"data\"),\n        data: z.any().refine((v) => typeof v !== \"undefined\", {\n          message: \"Data in steps must be defined\",\n        }),\n      })\n      .strict()\n      .or(\n        z\n          .object({\n            type: z.literal(\"error\").optional().default(\"error\"),\n            error: jsonErrorSchema,\n          })\n          .strict(),\n      )\n      .or(\n        z\n          .object({\n            type: z.literal(\"input\").optional().default(\"input\"),\n            input: z.any().refine((v) => typeof v !== \"undefined\", {\n              message: \"If input is present it must not be `undefined`\",\n            }),\n          })\n          .strict(),\n      )\n\n      /**\n       * If the result isn't a distcint `data` or `error` object, then it's\n       * likely that the executor has set this directly to a value, for example\n       * in the case of `sleep` or `waitForEvent`.\n       *\n       * In this case, pull the entire value through as data.\n       */\n\n      .or(z.any().transform((v) => ({ type: \"data\" as const, data: v }))),\n  )\n  .default({});\n\nconst v2StepSchema = v1StepSchema;\n\nexport const stepsSchemas = {\n  [ExecutionVersion.V0]: v0StepSchema,\n  [ExecutionVersion.V1]: v1StepSchema,\n  [ExecutionVersion.V2]: v2StepSchema,\n} satisfies Record<ExecutionVersion, z.ZodSchema>;\n\nexport type StepsResponse = {\n  [V in ExecutionVersion]: z.infer<(typeof stepsSchemas)[V]>;\n}[ExecutionVersion];\n\nexport const batchSchema = z.array(\n  z.record(z.any()).transform((v) => v as EventPayload),\n);\nexport type BatchResponse = z.infer<typeof batchSchema>;\n"],"mappings":";;;;;AAIA,MAAa,cAAc,EAAE,OAAO;CAClC,OAAO,EAAE,QAAQ;CACjB,QAAQ,EAAE,QAAQ;CACnB,CAAC;AAGF,MAAM,eAAe,EAClB,OACC,EAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EAC9C,SAAS,mCACV,CAAC,CACH,CACA,UAAU,CACV,UAAU;AAEb,MAAM,eAAe,EAClB,OACC,EACG,OAAO;CACN,MAAM,EAAE,QAAQ,OAAO,CAAC,UAAU,CAAC,QAAQ,OAAO;CAClD,MAAM,EAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EACpD,SAAS,iCACV,CAAC;CACH,CAAC,CACD,QAAQ,CACR,GACC,EACG,OAAO;CACN,MAAM,EAAE,QAAQ,QAAQ,CAAC,UAAU,CAAC,QAAQ,QAAQ;CACpD,OAAO;CACR,CAAC,CACD,QAAQ,CACZ,CACA,GACC,EACG,OAAO;CACN,MAAM,EAAE,QAAQ,QAAQ,CAAC,UAAU,CAAC,QAAQ,QAAQ;CACpD,OAAO,EAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EACrD,SAAS,kDACV,CAAC;CACH,CAAC,CACD,QAAQ,CACZ,CAUA,GAAG,EAAE,KAAK,CAAC,WAAW,OAAO;CAAE,MAAM;CAAiB,MAAM;CAAG,EAAE,CAAC,CACtE,CACA,QAAQ,EAAE,CAAC;AAEd,MAAM,eAAe;AAErB,MAAa,eAAe;EACzB,iBAAiB,KAAK;EACtB,iBAAiB,KAAK;EACtB,iBAAiB,KAAK;CACxB;AAMD,MAAa,cAAc,EAAE,MAC3B,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,WAAW,MAAM,EAAkB,CACtD"}