{"version":3,"file":"api.js","names":["data: unknown","json: unknown"],"sources":["../../src/api/api.ts"],"sourcesContent":["import type { fetch } from \"cross-fetch\";\nimport { z } from \"zod/v3\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  type ExecutionVersion,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable } from \"../helpers/devserver.ts\";\nimport type { Mode } from \"../helpers/env.ts\";\nimport { getErrorMessage } from \"../helpers/errors.ts\";\nimport { fetchWithAuthFallback } from \"../helpers/net.ts\";\nimport { hashSigningKey } from \"../helpers/strings.ts\";\nimport { err, ok, type Result } from \"../types.ts\";\nimport {\n  type BatchResponse,\n  batchSchema,\n  type ErrorResponse,\n  errorSchema,\n  type StepsResponse,\n  stepsSchemas,\n} from \"./schema.ts\";\n\ntype FetchT = typeof fetch;\n\nconst realtimeSubscriptionTokenSchema = z.object({\n  jwt: z.string(),\n});\n\nconst sendSignalSuccessResponseSchema = z.object({\n  data: z.object({\n    run_id: z.string().min(1),\n  }),\n});\n\nexport namespace InngestApi {\n  export interface Options {\n    baseUrl?: string;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    fetch: FetchT;\n    mode: Mode;\n  }\n\n  export interface Subscription {\n    topics: string[];\n    channel: string;\n  }\n\n  export interface PublishOptions extends Subscription {\n    runId?: string;\n  }\n\n  export interface SendSignalOptions {\n    signal: string;\n    data?: unknown;\n  }\n\n  export interface SendSignalResponse {\n    /**\n     * The ID of the run that was signaled.\n     *\n     * If this is undefined, the signal could not be matched to a run.\n     */\n    runId: string | undefined;\n  }\n}\n\nexport class InngestApi {\n  public apiBaseUrl?: string;\n  private signingKey: string;\n  private signingKeyFallback: string | undefined;\n  private readonly fetch: FetchT;\n  private mode: Mode;\n\n  constructor({\n    baseUrl,\n    signingKey,\n    signingKeyFallback,\n    fetch,\n    mode,\n  }: InngestApi.Options) {\n    this.apiBaseUrl = baseUrl;\n    this.signingKey = signingKey;\n    this.signingKeyFallback = signingKeyFallback;\n    this.fetch = fetch;\n    this.mode = mode;\n  }\n\n  private get hashedKey(): string {\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedFallbackKey(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return;\n    }\n\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  // set the signing key in case it was not instantiated previously\n  setSigningKey(key: string | undefined) {\n    if (typeof key === \"string\" && this.signingKey === \"\") {\n      this.signingKey = key;\n    }\n  }\n\n  setSigningKeyFallback(key: string | undefined) {\n    if (typeof key === \"string\" && !this.signingKeyFallback) {\n      this.signingKeyFallback = key;\n    }\n  }\n\n  private async getTargetUrl(path: string): Promise<URL> {\n    if (this.apiBaseUrl) {\n      return new URL(path, this.apiBaseUrl);\n    }\n\n    let url = new URL(path, defaultInngestApiBaseUrl);\n\n    if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = new URL(path, defaultDevServerHost);\n      }\n    }\n\n    return url;\n  }\n\n  async getRunSteps(\n    runId: string,\n    version: ExecutionVersion,\n  ): Promise<Result<StepsResponse, ErrorResponse>> {\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),\n    })\n      .then(async (resp) => {\n        const data: unknown = await resp.json();\n\n        if (resp.ok) {\n          return ok(stepsSchemas[version].parse(data));\n        } else {\n          return err(errorSchema.parse(data));\n        }\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error retrieving step data\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getRunBatch(\n    runId: string,\n  ): Promise<Result<BatchResponse, ErrorResponse>> {\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),\n    })\n      .then(async (resp) => {\n        const data: unknown = await resp.json();\n\n        if (resp.ok) {\n          return ok(batchSchema.parse(data));\n        } else {\n          return err(errorSchema.parse(data));\n        }\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error retrieving event batch\"),\n          status: 500,\n        });\n      });\n  }\n\n  async publish(\n    publishOptions: InngestApi.PublishOptions,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    data: any,\n  ): Promise<Result<void, ErrorResponse>> {\n    // todo it may not be a \"text/stream\"\n    const isStream = data instanceof ReadableStream;\n    const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n\n    url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n\n    if (publishOptions.runId) {\n      url.searchParams.set(\"run_id\", publishOptions.runId);\n    }\n\n    // biome-ignore lint/complexity/noForEach: <explanation>\n    publishOptions.topics.forEach((topic) => {\n      url.searchParams.append(\"topic\", topic);\n    });\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: isStream\n          ? data\n          : typeof data === \"string\"\n            ? data\n            : JSON.stringify(data),\n        headers: {\n          \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n        },\n        ...(isStream ? { duplex: \"half\" } : {}),\n      },\n    })\n      .then((res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to publish event: ${res.status} ${res.statusText}`,\n          );\n        }\n\n        return ok<void>(undefined);\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error publishing event\"),\n          status: 500,\n        });\n      });\n  }\n\n  async sendSignal(\n    signalOptions: InngestApi.SendSignalOptions,\n    options?: {\n      headers?: Record<string, string>;\n    },\n  ): Promise<Result<InngestApi.SendSignalResponse, ErrorResponse>> {\n    const url = await this.getTargetUrl(\"/v1/signals\");\n\n    const body = {\n      signal: signalOptions.signal,\n      data: signalOptions.data,\n    };\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...options?.headers,\n        },\n      },\n    })\n      .then(async (res) => {\n        // A 404 is valid if the signal was not found.\n        if (res.status === 404) {\n          return ok<InngestApi.SendSignalResponse>({\n            runId: undefined,\n          });\n        }\n\n        // Save a clone of the response we can use to get the text of if we fail\n        // to parse the JSON.\n        const resClone = res.clone();\n\n        // JSON!\n        let json: unknown;\n        try {\n          json = await res.json();\n        } catch {\n          // res.json() failed so not a valid JSON response\n          return err({\n            error: `Failed to send signal: ${res.status} ${\n              res.statusText\n            } - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        // If we're not 2xx, something went wrong.\n        if (!res.ok) {\n          try {\n            return err(errorSchema.parse(json));\n          } catch {\n            // schema parse failed\n            return err({\n              error: `Failed to send signal: ${res.status} ${\n                res.statusText\n              } - ${await res.text()}`,\n              status: res.status,\n            });\n          }\n        }\n\n        // If we are 2xx, we should have a run_id.\n        const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n        if (!parseRes.success) {\n          return err({\n            error: `Successfully sent signal, but response parsing failed: ${\n              res.status\n            } ${res.statusText} - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        return ok({\n          runId: parseRes.data.data.run_id,\n        });\n      })\n      .catch((error) => {\n        // Catch-all if various things go wrong\n        return err({\n          error: getErrorMessage(error, \"Unknown error sending signal\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getSubscriptionToken(\n    channel: string,\n    topics: string[],\n  ): Promise<string> {\n    const url = await this.getTargetUrl(\"/v1/realtime/token\");\n\n    const body = topics.map((topic) => ({\n      channel,\n      name: topic,\n      kind: \"run\",\n    }));\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      },\n    })\n      .then(async (res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to get subscription token: ${res.status} ${\n              res.statusText\n            } - ${await res.text()}`,\n          );\n        }\n\n        const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n\n        return data.jwt;\n      })\n      .catch((error) => {\n        throw new Error(\n          getErrorMessage(error, \"Unknown error getting subscription token\"),\n        );\n      });\n  }\n}\n"],"mappings":"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"}